"0","#Walkthrough code for z-standardizing b.sidi:"
"0",""
"0","  #Calculate the sample mean and sd:"
"0","  b_sidi_mean = mean(dat_all$b.sidi, na.rm = TRUE)"
"0","  b_sidi_sd   = sd(dat_all$b.sidi, na.rm = TRUE)"
"0","  "
"0","  # Use the subset-by-name symbol ($) to create a "
"0","  # new column of z-standardized values."
"0","  "
"0","  dat_all$b.sidi.standardized = (dat_all$b.sidi - b_sidi_mean)/b_sidi_sd"
"0","  "
"0","  mean(dat_all$b.sidi.standardized)"
"1","[1]"
"1"," 7.166938e-17"
"1","
"
"0","  #note that this value is effectively 0"
"0","  sd(dat_all$b.sidi.standardized)"
"1","[1]"
"1"," 1"
"1","
"
"0","#Q12 - Briefly describe the Simpson diversity index, and explain what it quantifies."
"0","#The Simpson diversity index is used to quantify the diversity of species for a given sample. It uses the number of individuals of each species and the number of different species present in a given sample. A sample is more diverse if the number of individuals per species is relatively even or there is not one or two species that comprise almost all of the individuals sampled. "
"0",""
"0","#Q13 - Code for z-standardizing for s.sidi column"
"0","  # Calculate the sample mean and sd:"
"0","  s_sidi_mean = mean(dat_all$s.sidi, na.rm = TRUE)"
"0","  s_sidi_sd   = sd(dat_all$s.sidi, na.rm = TRUE)"
"0","  "
"0","  # Use the subset-by-name symbol ($) to create a "
"0","  # new column of z-standardized values."
"0","  "
"0","  dat_all$s.sidi.standardized = (dat_all$s.sidi - s_sidi_mean)/s_sidi_sd"
"0","  "
"0","  mean(dat_all$s.sidi.standardized)"
"1","[1]"
"1"," 2.984718e-17"
"1","
"
"0","  #note that this value is effectively 0"
"0","  sd(dat_all$s.sidi.standardized)"
"1","[1]"
"1"," 1"
"1","
"
"0","  "
"0","#Q14 (6 pts.): Show the code for your completed Monte Carlo simulation loop."
"0","  "
"0","    #We'll use the select argument to extract just the two variables we need from the      data. then we will use a Monte Carlo randomization procedure to construct our own      null hypothesis test because we don't want to use the lm() function and assume the     errors are normally distributed around the mean. "
"0","  "
"0","    dat_1 = "
"0","    subset("
"0","      dat_all,"
"0","      select = c(b.sidi, s.sidi))"
"0","  "
"0","  #Use numeric to create a vector to hold the results"
"0","  m = 10000 "
"0","  result_mc = numeric(m)"
"0","  "
"0","  for(i in 1:m)"
"0","  {"
"0","    index_1 = sample(nrow(dat_1), replace = TRUE)"
"0","    index_2 = sample(nrow(dat_1), replace = TRUE)"
"0","    "
"0","    dat_resampled_i = "
"0","    data.frame("
"0","      b.sidi = dat_1$b.sidi[index_1],"
"0","      s.sidi = dat_1$s.sidi[index_2]"
"0","    )"
"0","  "
"0","  fit_resampled_i = lm(b.sidi ~ s.sidi, data = dat_resampled_i)"
"0","    "
"0","    result_mc[i] = coef(fit_resampled_i)[2]"
"0","  } "
"0",""
"0",""
"0","#Q15 (2 pts.): In your report, include a plot of your histogram of Monte Carlo resampled slopes. Include vertical lines showing the observed slope and the critical value from the resampled MC slopes."
"0","  "
"0","  critical_mc = quantile(result_mc, c(.05))"
"0","  "
"0","  hist("
"0","    result_mc,"
"0","    main = ""Monte Carlo Null Distribution Slopes\n n=10,000"","
"0","    xlab = ""Slope Parameter"")"
