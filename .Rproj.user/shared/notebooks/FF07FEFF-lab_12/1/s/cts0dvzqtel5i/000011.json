[{"name":"htmlwidgets","version":"1.5.4","src":{"file":"www"},"meta":null,"script":"htmlwidgets.js","stylesheet":null,"head":null,"attachment":null,"package":"htmlwidgets","all_files":true},{"name":"rglWebGL-binding","version":"0.110.2","src":{"file":"htmlwidgets"},"meta":null,"script":"rglWebGL.js","stylesheet":null,"head":null,"attachment":null,"package":"rgl","all_files":false},{"name":"rglwidgetClass","version":"0.110.2","src":{"file":"htmlwidgets\/lib\/rglClass"},"meta":null,"script":["rglClass.src.js","utils.src.js","buffer.src.js","subscenes.src.js","shaders.src.js","textures.src.js","projection.src.js","mouse.src.js","init.src.js","pieces.src.js","draw.src.js","controls.src.js","selection.src.js","rglTimer.src.js","pretty.src.js","axes.src.js","animation.src.js"],"stylesheet":"rgl.css","head":"<!--html_preserve--><script type = \"text\/plain\" id = \"rgl-vertex-shader\">\u000A#line 2 1\u000A\/\/ File 1 is the vertex shader\u000A#ifdef GL_ES\u000A#ifdef GL_FRAGMENT_PRECISION_HIGH\u000Aprecision highp float;\u000A#else\u000Aprecision mediump float;\u000A#endif\u000A#endif\u000A\u000Aattribute vec3 aPos;\u000Aattribute vec4 aCol;\u000Auniform mat4 mvMatrix;\u000Auniform mat4 prMatrix;\u000Avarying vec4 vCol;\u000Avarying vec4 vPosition;\u000A\u000A#ifdef NEEDS_VNORMAL\u000Aattribute vec3 aNorm;\u000Auniform mat4 normMatrix;\u000Avarying vec4 vNormal;\u000A#endif\u000A\u000A#if defined(HAS_TEXTURE) || defined (IS_TEXT)\u000Aattribute vec2 aTexcoord;\u000Avarying vec2 vTexcoord;\u000A#endif\u000A\u000A#ifdef FIXED_SIZE\u000Auniform vec3 textScale;\u000A#endif\u000A\u000A#ifdef FIXED_QUADS\u000Aattribute vec3 aOfs;\u000A#endif\u000A\u000A#ifdef IS_TWOSIDED\u000A#ifdef HAS_NORMALS\u000Avarying float normz;\u000Auniform mat4 invPrMatrix;\u000A#else\u000Aattribute vec3 aPos1;\u000Aattribute vec3 aPos2;\u000Avarying float normz;\u000A#endif\u000A#endif \/\/ IS_TWOSIDED\u000A\u000A#ifdef FAT_LINES\u000Aattribute vec3 aNext;\u000Aattribute vec2 aPoint;\u000Avarying vec2 vPoint;\u000Avarying float vLength;\u000Auniform float uAspect;\u000Auniform float uLwd;\u000A#endif\u000A\u000A\u000Avoid main(void) {\u000A  \u000A#ifndef IS_BRUSH\u000A#if defined(NCLIPPLANES) || !defined(FIXED_QUADS) || defined(HAS_FOG)\u000A  vPosition = mvMatrix * vec4(aPos, 1.);\u000A#endif\u000A  \u000A#ifndef FIXED_QUADS\u000A  gl_Position = prMatrix * vPosition;\u000A#endif\u000A#endif \/\/ !IS_BRUSH\u000A  \u000A#ifdef IS_POINTS\u000A  gl_PointSize = POINTSIZE;\u000A#endif\u000A  \u000A  vCol = aCol;\u000A  \u000A#ifdef NEEDS_VNORMAL\u000A  vNormal = normMatrix * vec4(-aNorm, dot(aNorm, aPos));\u000A#endif\u000A  \u000A#ifdef IS_TWOSIDED\u000A#ifdef HAS_NORMALS\u000A  \/* normz should be calculated *after* projection *\/\u000A  normz = (invPrMatrix*vNormal).z;\u000A#else\u000A  vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\u000A  pos1 = pos1\/pos1.w - gl_Position\/gl_Position.w;\u000A  vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\u000A  pos2 = pos2\/pos2.w - gl_Position\/gl_Position.w;\u000A  normz = pos1.x*pos2.y - pos1.y*pos2.x;\u000A#endif\u000A#endif \/\/ IS_TWOSIDED\u000A  \u000A#ifdef NEEDS_VNORMAL\u000A  vNormal = vec4(normalize(vNormal.xyz\/vNormal.w), 1);\u000A#endif\u000A  \u000A#if defined(HAS_TEXTURE) || defined(IS_TEXT)\u000A  vTexcoord = aTexcoord;\u000A#endif\u000A  \u000A#if defined(FIXED_SIZE) && !defined(ROTATING)\u000A  vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\u000A  pos = pos\/pos.w;\u000A  gl_Position = pos + vec4(aOfs*textScale, 0.);\u000A#endif\u000A  \u000A#if defined(IS_SPRITES) && !defined(FIXED_SIZE)\u000A  vec4 pos = mvMatrix * vec4(aPos, 1.);\u000A  pos = pos\/pos.w + vec4(aOfs,  0.);\u000A  gl_Position = prMatrix*pos;\u000A#endif\u000A  \u000A#ifdef FAT_LINES\u000A  \/* This code was inspired by Matt Deslauriers' code in \u000A   https:\/\/mattdesl.svbtle.com\/drawing-lines-is-hard *\/\u000A  vec2 aspectVec = vec2(uAspect, 1.0);\u000A  mat4 projViewModel = prMatrix * mvMatrix;\u000A  vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\u000A  currentProjected = currentProjected\/currentProjected.w;\u000A  vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\u000A  vec2 currentScreen = currentProjected.xy * aspectVec;\u000A  vec2 nextScreen = (nextProjected.xy \/ nextProjected.w) * aspectVec;\u000A  float len = uLwd;\u000A  vec2 dir = vec2(1.0, 0.0);\u000A  vPoint = aPoint;\u000A  vLength = length(nextScreen - currentScreen)\/2.0;\u000A  vLength = vLength\/(vLength + len);\u000A  if (vLength > 0.0) {\u000A    dir = normalize(nextScreen - currentScreen);\u000A  }\u000A  vec2 normal = vec2(-dir.y, dir.x);\u000A  dir.x \/= uAspect;\u000A  normal.x \/= uAspect;\u000A  vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\u000A  gl_Position = currentProjected + offset;\u000A#endif\u000A  \u000A#ifdef IS_BRUSH\u000A  gl_Position = vec4(aPos, 1.);\u000A#endif\u000A}\u000A<\/script>\u000A<script type = \"text\/plain\" id = \"rgl-fragment-shader\">\u000A#line 2 2\u000A\/\/ File 2 is the fragment shader\u000A#ifdef GL_ES\u000A#ifdef GL_FRAGMENT_PRECISION_HIGH\u000Aprecision highp float;\u000A#else\u000Aprecision mediump float;\u000A#endif\u000A#endif\u000Avarying vec4 vCol; \/\/ carries alpha\u000Avarying vec4 vPosition;\u000A#if defined(HAS_TEXTURE) || defined (IS_TEXT)\u000Avarying vec2 vTexcoord;\u000Auniform sampler2D uSampler;\u000A#endif\u000A\u000A#ifdef HAS_FOG\u000Auniform int uFogMode;\u000Auniform vec3 uFogColor;\u000Auniform vec4 uFogParms;\u000A#endif\u000A\u000A#if defined(IS_LIT) && !defined(FIXED_QUADS)\u000Avarying vec4 vNormal;\u000A#endif\u000A\u000A#if NCLIPPLANES > 0\u000Auniform vec4 vClipplane[NCLIPPLANES];\u000A#endif\u000A\u000A#if NLIGHTS > 0\u000Auniform mat4 mvMatrix;\u000A#endif\u000A\u000A#ifdef IS_LIT\u000Auniform vec3 emission;\u000Auniform float shininess;\u000A#if NLIGHTS > 0\u000Auniform vec3 ambient[NLIGHTS];\u000Auniform vec3 specular[NLIGHTS]; \/\/ light*material\u000Auniform vec3 diffuse[NLIGHTS];\u000Auniform vec3 lightDir[NLIGHTS];\u000Auniform bool viewpoint[NLIGHTS];\u000Auniform bool finite[NLIGHTS];\u000A#endif\u000A#endif \/\/ IS_LIT\u000A\u000A#ifdef IS_TWOSIDED\u000Auniform bool front;\u000Avarying float normz;\u000A#endif\u000A\u000A#ifdef FAT_LINES\u000Avarying vec2 vPoint;\u000Avarying float vLength;\u000A#endif\u000A\u000Avoid main(void) {\u000A  vec4 fragColor;\u000A#ifdef FAT_LINES\u000A  vec2 point = vPoint;\u000A  bool neg = point.y < 0.0;\u000A  point.y = neg ? (point.y + vLength)\/(1.0 - vLength) :\u000A                 -(point.y - vLength)\/(1.0 - vLength);\u000A#if defined(IS_TRANSPARENT) && defined(IS_LINESTRIP)\u000A  if (neg && length(point) <= 1.0) discard;\u000A#endif\u000A  point.y = min(point.y, 0.0);\u000A  if (length(point) > 1.0) discard;\u000A#endif \/\/ FAT_LINES\u000A  \u000A#ifdef ROUND_POINTS\u000A  vec2 coord = gl_PointCoord - vec2(0.5);\u000A  if (length(coord) > 0.5) discard;\u000A#endif\u000A  \u000A#if NCLIPPLANES > 0\u000A  for (int i = 0; i < NCLIPPLANES; i++)\u000A    if (dot(vPosition, vClipplane[i]) < 0.0) discard;\u000A#endif\u000A    \u000A#ifdef FIXED_QUADS\u000A    vec3 n = vec3(0., 0., 1.);\u000A#elif defined(IS_LIT)\u000A    vec3 n = normalize(vNormal.xyz);\u000A#endif\u000A    \u000A#ifdef IS_TWOSIDED\u000A    if ((normz <= 0.) != front) discard;\u000A#endif\u000A    \u000A#ifdef IS_LIT\u000A    vec3 eye = normalize(-vPosition.xyz\/vPosition.w);\u000A    vec3 lightdir;\u000A    vec4 colDiff;\u000A    vec3 halfVec;\u000A    vec4 lighteffect = vec4(emission, 0.);\u000A    vec3 col;\u000A    float nDotL;\u000A#ifdef FIXED_QUADS\u000A    n = -faceforward(n, n, eye);\u000A#endif\u000A    \u000A#if NLIGHTS > 0\u000A    for (int i=0;i<NLIGHTS;i++) {\u000A      colDiff = vec4(vCol.rgb * diffuse[i], vCol.a);\u000A      lightdir = lightDir[i];\u000A      if (!viewpoint[i])\u000A        lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\u000A      if (!finite[i]) {\u000A        halfVec = normalize(lightdir + eye);\u000A      } else {\u000A        lightdir = normalize(lightdir - vPosition.xyz\/vPosition.w);\u000A        halfVec = normalize(lightdir + eye);\u000A      }\u000A      col = ambient[i];\u000A      nDotL = dot(n, lightdir);\u000A      col = col + max(nDotL, 0.) * colDiff.rgb;\u000A      col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular[i];\u000A      lighteffect = lighteffect + vec4(col, colDiff.a);\u000A    }\u000A#endif\u000A    \u000A#else \/\/ not IS_LIT\u000A    vec4 colDiff = vCol;\u000A    vec4 lighteffect = colDiff;\u000A#endif\u000A    \u000A#ifdef IS_TEXT\u000A    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\u000A#endif\u000A    \u000A#ifdef HAS_TEXTURE\u000A#ifdef TEXTURE_rgb\u000A    vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);\u000A#endif\u000A    \u000A#ifdef TEXTURE_rgba\u000A    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\u000A#endif\u000A    \u000A#ifdef TEXTURE_alpha\u000A    vec4 textureColor = texture2D(uSampler, vTexcoord);\u000A    float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)\/3.;\u000A    textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);\u000A#endif\u000A    \u000A#ifdef TEXTURE_luminance\u000A    vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))\/3., lighteffect.a);\u000A#endif\u000A    \u000A#ifdef TEXTURE_luminance_alpha\u000A    vec4 textureColor = texture2D(uSampler, vTexcoord);\u000A    float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)\/3.;\u000A    textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);\u000A#endif\u000A    \u000A    fragColor = textureColor;\u000A\u000A#elif defined(IS_TEXT)\u000A    if (textureColor.a < 0.1)\u000A      discard;\u000A    else\u000A      fragColor = textureColor;\u000A#else\u000A    fragColor = lighteffect;\u000A#endif \/\/ HAS_TEXTURE\u000A    \u000A#ifdef HAS_FOG\u000A    \/\/ uFogParms elements: x = near, y = far, z = fogscale, w = (1-sin(FOV\/2))\/(1+sin(FOV\/2))\u000A    \/\/ In Exp and Exp2: use density = density\/far\u000A    \/\/ fogF will be the proportion of fog\u000A    \/\/ Initialize it to the linear value\u000A    float fogF;\u000A    if (uFogMode > 0) {\u000A      fogF = (uFogParms.y - vPosition.z\/vPosition.w)\/(uFogParms.y - uFogParms.x);\u000A      if (uFogMode > 1)\u000A        fogF = mix(uFogParms.w, 1.0, fogF);\u000A      fogF = fogF*uFogParms.z;\u000A      if (uFogMode == 2)\u000A        fogF = 1.0 - exp(-fogF);\u000A      \/\/ Docs are wrong: use (density*c)^2, not density*c^2\u000A      \/\/ https:\/\/gitlab.freedesktop.org\/mesa\/mesa\/-\/blob\/master\/src\/mesa\/swrast\/s_fog.c#L58\u000A      else if (uFogMode == 3)\u000A        fogF = 1.0 - exp(-fogF*fogF);\u000A      fogF = clamp(fogF, 0.0, 1.0);\u000A      gl_FragColor = vec4(mix(fragColor.rgb, uFogColor, fogF), fragColor.a);\u000A    } else gl_FragColor = fragColor;\u000A#else\u000A    gl_FragColor = fragColor;\u000A#endif \/\/ HAS_FOG\u000A    \u000A}\u000A<\/script><!--\/html_preserve-->","attachment":null,"package":"rgl","all_files":false},{"name":"CanvasMatrix4","version":"0.110.2","src":{"file":"htmlwidgets\/lib\/CanvasMatrix"},"meta":null,"script":"CanvasMatrix.src.js","stylesheet":null,"head":null,"attachment":null,"package":"rgl","all_files":false}]
